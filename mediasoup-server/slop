Listing JavaScript files and their contents in current directory:
FILENAME: public/client.js
CONTENTS:
// Import dependencies
import 'webrtc-adapter';
import * as mediasoupClient from 'mediasoup-client';

let device;
let transport;
let producers = new Map(); // kind -> producer
let consumers = new Map(); // kind -> consumer
let isRecording = false;
let isPlaying = false;
let currentClientId = null;
let mediaStream = null;
let ws;

// Wait for DOM to be loaded before accessing elements
document.addEventListener('DOMContentLoaded', () => {
    const localVideo = document.getElementById('localVideo');
    const remoteVideo = document.getElementById('remoteVideo');
    const recordButton = document.getElementById('recordButton');
    const playButton = document.getElementById('playButton');
    const statusDiv = document.getElementById('status');

    function updateStatus(message) {
        statusDiv.textContent = message;
        console.log('Status:', message);
    }

    // Initialize UI
    recordButton.addEventListener('click', toggleRecording);
    playButton.addEventListener('click', togglePlayback);
    recordButton.disabled = true; // Disable until streaming is ready
    playButton.disabled = true; // Disable until playback is ready

    // Initialize WebSocket connection
    initializeWebSocket();

    function initializeWebSocket() {
        ws = new WebSocket('ws://' + window.location.hostname + ':3000');

        ws.onopen = async () => {
            updateStatus('Connected to server');
            // Initialize camera immediately
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = mediaStream;
                updateStatus('Camera ready');
                
                // Request router capabilities
                ws.send(JSON.stringify({ type: 'getRouterRtpCapabilities' }));
            } catch (error) {
                console.error('Failed to get user media:', error);
                updateStatus('Failed to access camera');
            }
        };

        ws.onclose = () => {
            updateStatus('Disconnected from server');
            stopMediaTracks();
            // Try to reconnect after a delay
            setTimeout(initializeWebSocket, 5000);
        };

        ws.onerror = (error) => {
            console.error('WebSocket error:', error);
            updateStatus('WebSocket error');
            stopMediaTracks();
        };

        ws.onmessage = async ({ data }) => {
            const message = JSON.parse(data);
            console.log('Received message:', message.type, message.data);

            try {
                switch (message.type) {
                    case 'routerRtpCapabilities':
                        await loadDevice(message.data);
                        break;
                    
                    case 'transportCreated':
                        await connectTransport(message.data);
                        break;

                    case 'transportConnected':
                        await startStreaming();
                        break;

                    case 'produced':
                        handleProduced(message.data);
                        break;

                    case 'recordingStarted':
                        handleRecordingStarted(message.data);
                        break;

                    case 'recordingStopped':
                        handleRecordingStopped(message.data);
                        break;

                    case 'playbackStarted':
                        await handlePlaybackStarted(message.data);
                        break;

                    case 'playbackStopped':
                        handlePlaybackStopped();
                        break;

                    case 'error':
                        console.error('Server error:', message.data);
                        updateStatus('Error: ' + message.data);
                        break;
                }
            } catch (error) {
                console.error('Error handling message:', error);
                updateStatus('Error: ' + error.message);
            }
        };
    }

    async function loadDevice(routerRtpCapabilities) {
        try {
            device = new mediasoupClient.Device();
            await device.load({ routerRtpCapabilities });
            updateStatus('Device loaded');
            // Create transport right after device is loaded
            ws.send(JSON.stringify({ type: 'createTransport' }));
        } catch (error) {
            console.error('Failed to load device:', error);
            updateStatus('Failed to load device: ' + error.message);
        }
    }

    async function connectTransport({ id, iceParameters, iceCandidates, dtlsParameters }) {
        try {
            updateStatus('Setting up transport...');
            transport = device.createSendTransport({
                id,
                iceParameters,
                iceCandidates,
                dtlsParameters
            });

            transport.on('connect', async ({ dtlsParameters }, callback, errback) => {
                try {
                    ws.send(JSON.stringify({
                        type: 'connectTransport',
                        data: { dtlsParameters }
                    }));
                    callback();
                } catch (error) {
                    errback(error);
                }
            });

            transport.on('produce', async ({ kind, rtpParameters }, callback, errback) => {
                try {
                    ws.send(JSON.stringify({
                        type: 'produce',
                        data: { kind, rtpParameters }
                    }));
                    callback({ id: await new Promise(resolve => {
                        const handler = ({ data }) => {
                            const message = JSON.parse(data);
                            if (message.type === 'produced' && message.data.kind === kind) {
                                ws.removeEventListener('message', handler);
                                resolve(message.data.id);
                            }
                        };
                        ws.addEventListener('message', handler);
                    })});
                } catch (error) {
                    errback(error);
                }
            });

            updateStatus('Transport connected');
        } catch (error) {
            console.error('Failed to create transport:', error);
            updateStatus('Failed to create transport: ' + error.message);
        }
    }

    async function startStreaming() {
        if (!mediaStream || !mediaStream.active) {
            try {
                mediaStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = mediaStream;
            } catch (error) {
                console.error('Failed to get user media:', error);
                updateStatus('Failed to access camera: ' + error.message);
                return;
            }
        }

        try {
            updateStatus('Creating producers...');
            
            // Create video producer
            const videoTrack = mediaStream.getVideoTracks()[0];
            const videoProducer = await transport.produce({
                track: videoTrack,
                encodings: [
                    { maxBitrate: 100000 },
                    { maxBitrate: 300000 },
                    { maxBitrate: 900000 }
                ],
                codecOptions: {
                    videoGoogleStartBitrate: 1000
                }
            });
            producers.set('video', videoProducer);

            // Create audio producer
            const audioTrack = mediaStream.getAudioTracks()[0];
            const audioProducer = await transport.produce({
                track: audioTrack,
                codecOptions: {
                    opusStereo: true,
                    opusDtx: true
                }
            });
            producers.set('audio', audioProducer);

            // Enable buttons once everything is ready
            recordButton.disabled = false;
            playButton.disabled = false;
            updateStatus('Ready to record');
        } catch (error) {
            console.error('Failed to create producers:', error);
            updateStatus('Failed to create producers: ' + error.message);
        }
    }

    function handleProduced({ id, kind }) {
        console.log(`${kind} producer created with id ${id}`);
        // The producer is already stored in the producers Map during transport.produce()
    }

    async function toggleRecording() {
        if (!isRecording) {
            try {
                updateStatus('Starting stream...');
                // Send startRecording message to server
                ws.send(JSON.stringify({
                    type: 'startRecording'
                }));
                await Promise.all([
                    producers.get('video').resume(),
                    producers.get('audio').resume()
                ]);
                // isRecording will be set to true when server confirms with 'recordingStarted' message
                updateStatus('Stream active');
            } catch (error) {
                console.error('Error starting recording:', error);
                updateStatus('Failed to start streaming');
            }
        } else {
            try {
                updateStatus('Stopping stream...');
                // Send stopRecording message to server
                ws.send(JSON.stringify({
                    type: 'stopRecording',
                    clientId: currentClientId
                }));
                await Promise.all([
                    producers.get('video').pause(),
                    producers.get('audio').pause()
                ]);
                
                // Make sure local video track is still enabled
                if (mediaStream) {
                    mediaStream.getVideoTracks().forEach(track => {
                        track.enabled = true;
                    });
                }
                
                // isRecording will be set to false when server confirms with 'recordingStopped' message
                updateStatus('Stream paused');
            } catch (error) {
                console.error('Error stopping recording:', error);
                updateStatus('Failed to stop streaming');
            }
        }
    }

    function handleRecordingStarted({ timestamp }) {
        console.log('Recording started at:', timestamp);
        isRecording = true;
        currentClientId = timestamp;
        document.getElementById('recordButton').textContent = 'Stop Recording';
        document.getElementById('recordButton').classList.add('recording');
    }

    function handleRecordingStopped({ timestamp }) {
        console.log('Recording stopped at:', timestamp);
        isRecording = false;
        document.getElementById('recordButton').textContent = 'Start Recording';
        document.getElementById('recordButton').classList.remove('recording');
        // Just pause the producers instead of closing them
        if (producers.get('video')) {
            try {
                producers.get('video').pause();
            } catch (error) {
                console.error('Error pausing video producer:', error);
            }
        }
        if (producers.get('audio')) {
            try {
                producers.get('audio').pause();
            } catch (error) {
                console.error('Error pausing audio producer:', error);
            }
        }
    }

    async function handlePlaybackStarted({ audio, video }) {
        try {
            // Create audio consumer
            const audioConsumer = await producers.get('audio').consume({
                id: audio.id,
                producerId: audio.producerId,
                kind: audio.kind,
                rtpParameters: audio.rtpParameters
            });
            consumers.set('audio', audioConsumer);

            // Create video consumer
            const videoConsumer = await producers.get('video').consume({
                id: video.id,
                producerId: video.producerId,
                kind: video.kind,
                rtpParameters: video.rtpParameters
            });
            consumers.set('video', videoConsumer);

            // Create a new MediaStream with the consumer tracks
            const stream = new MediaStream([
                videoConsumer.track,
                audioConsumer.track
            ]);

            // Display the remote stream
            remoteVideo.srcObject = stream;
            isPlaying = true;
            document.getElementById('playButton').textContent = 'Stop Playback';
        } catch (error) {
            console.error('Failed to start playback:', error);
        }
    }

    function handlePlaybackStopped() {
        // Clear remote video
        remoteVideo.srcObject = null;
        
        // Close and clear consumers
        for (const consumer of consumers.values()) {
            consumer.close();
        }
        consumers.clear();
        
        isPlaying = false;
        document.getElementById('playButton').textContent = 'Start Playback';
    }

    function stopMediaTracks() {
        // Only stop tracks when actually cleaning up (e.g., page unload or explicit stop)
        if (mediaStream) {
            mediaStream.getTracks().forEach(track => {
                track.stop();
            });
            mediaStream = null;
        }
        if (localVideo.srcObject) {
            localVideo.srcObject = null;
        }
        if (producers.get('video')) {
            try {
                producers.get('video').close();
            } catch (error) {
                console.error('Error closing video producer:', error);
            }
            producers.delete('video');
        }
        if (producers.get('audio')) {
            try {
                producers.get('audio').close();
            } catch (error) {
                console.error('Error closing audio producer:', error);
            }
            producers.delete('audio');
        }
    }

    async function togglePlayback() {
        if (!isPlaying) {
            try {
                // For simplicity, we'll play the last recording
                // In a real app, you might want to show a list of recordings to choose from
                ws.send(JSON.stringify({
                    type: 'startPlayback',
                    data: { timestamp: Date.now() } // This should be the actual recording timestamp
                }));
            } catch (error) {
                console.error('Error starting playback:', error);
                updateStatus('Failed to start playback');
            }
        } else {
            try {
                ws.send(JSON.stringify({ type: 'stopPlayback' }));
                // Clear remote video
                remoteVideo.srcObject = null;
                
                // Close and clear consumers
                for (const consumer of consumers.values()) {
                    consumer.close();
                }
                consumers.clear();
                
                isPlaying = false;
                document.getElementById('playButton').textContent = 'Start Playback';
            } catch (error) {
                console.error('Error stopping playback:', error);
                updateStatus('Failed to stop playback');
            }
        }
    }

    window.addEventListener('beforeunload', () => {
        if (mediaStream) {
            mediaStream.getTracks().forEach(track => track.stop());
        }
        
        for (const producer of producers.values()) {
            producer.close();
        }
        
        for (const consumer of consumers.values()) {
            consumer.close();
        }
        
        if (transport) {
            transport.close();
        }
    });
}); ---
FILENAME: server.js
CONTENTS:
const express = require('express');
const http = require('http');
const WebSocket = require('ws');
const path = require('path');

const MediasoupManager = require('./src/MediasoupManager');
const WebSocketHandler = require('./src/WebSocketHandler');

const app = express();
app.use(express.static(path.join(__dirname, 'public')));

const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

// Initialize managers
const mediasoupManager = new MediasoupManager();
const wsHandler = new WebSocketHandler(mediasoupManager);

// Handle WebSocket connections
wss.on('connection', (ws) => {
  wsHandler.handleConnection(ws);
});

// Start the server
const PORT = process.env.PORT || 3000;

async function start() {
  try {
    await mediasoupManager.init();
    server.listen(PORT, () => {
      console.log(`Server running on port ${PORT}`);
    });
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
}

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM signal received: closing HTTP server');
  server.close(() => {
    console.log('HTTP server closed');
    mediasoupManager.close();
    process.exit(0);
  });
});

start(); ---
FILENAME: src/BufferManager.js
CONTENTS:
class BufferManager {
  constructor() {
    this.buffers = new Map();
    this.history = [];
    this.rtpBuffers = new Map(); // Store RTP data
  }

  createBuffer(clientId) {
    this.buffers.set(clientId, []);
    this.rtpBuffers.set(clientId, []);
    console.log(`[Buffer] New recording started for client ${clientId}`);
    return true;
  }

  appendPacket(clientId, packet) {
    const buffer = this.buffers.get(clientId);
    console.log(`[Buffer] Appending packet for client ${clientId}`);
    if (buffer) {
      buffer.push(packet);
      return true;
    }
    return false;
  }

  appendRtpData(clientId, rtpData) {
    const buffer = this.rtpBuffers.get(clientId);
    console.log(`[Buffer] Appending RTP data for client ${clientId}`);
    if (buffer) {
      buffer.push(rtpData);
      return true;
    }
    return false;
  }

  markBufferComplete(clientId) {
    const buffer = this.buffers.get(clientId);
    const rtpBuffer = this.rtpBuffers.get(clientId);
    if (buffer && rtpBuffer) {
      const bufferSizeKB = this._calculateBufferSize(rtpBuffer);
      console.log(`[Buffer] Recording stopped for client ${clientId}. Buffer size: ${bufferSizeKB.toFixed(2)} KB, RTP packets: ${rtpBuffer.length}, Control packets: ${buffer.length}`);
      
      this.history.push({ 
        clientId, 
        timestamp: Date.now(),
        rtpPacketCount: rtpBuffer.length,
        totalPacketCount: buffer.length,
        bufferSizeKB: bufferSizeKB
      });
      return true;
    }
    return false;
  }

  getBufferedData(clientId, offset = 0) {
    const buffer = this.buffers.get(clientId);
    const rtpBuffer = this.rtpBuffers.get(clientId);
    if (buffer && rtpBuffer) {
      console.log(`[Buffer] Accessing recording for client ${clientId} at offset ${offset}. Total available packets: ${rtpBuffer.length - offset}`);
      return {
        controlPackets: buffer.slice(offset),
        rtpData: rtpBuffer.slice(offset)
      };
    }
    return null;
  }

  clearBuffer(clientId) {
    this.buffers.delete(clientId);
    this.rtpBuffers.delete(clientId);
  }

  getRecordingHistory() {
    return this.history;
  }

  _calculateBufferSize(rtpBuffer) {
    return rtpBuffer.reduce((total, packet) => total + (packet.byteLength || 0), 0) / 1024;
  }
}

module.exports = BufferManager; ---
FILENAME: src/GstreamerManager.js
CONTENTS:
const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

class GstreamerManager {
  constructor() {
    this.recordingProcesses = new Map(); // clientId -> {audio: process, video: process}
    this.playbackProcesses = new Map(); // clientId -> {audio: process, video: process}
    this.recordingsPath = path.join(__dirname, '..', 'recordings');
    
    // Ensure recordings directory exists
    if (!fs.existsSync(this.recordingsPath)) {
      fs.mkdirSync(this.recordingsPath, { recursive: true });
    }
  }

  getRecordingPath(clientId, timestamp) {
    const dir = path.join(this.recordingsPath, `${clientId}_${timestamp}`);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    return dir;
  }

  startRecording(clientId) {
    const timestamp = Date.now();
    const recordingDir = this.getRecordingPath(clientId, timestamp);
    
    try {
      // Start audio recording pipeline - raw RTP
      const audioProcess = spawn('gst-launch-1.0', [
        'udpsrc',
        'port=0',
        'caps="application/x-rtp,media=audio,clock-rate=48000,encoding-name=OPUS"',
        '!',
        'filesink',
        `location=${path.join(recordingDir, 'audio.rtp')}`
      ]);

      // Start video recording pipeline - raw RTP
      const videoProcess = spawn('gst-launch-1.0', [
        'udpsrc',
        'port=0',
        'caps="application/x-rtp,media=video,clock-rate=90000,encoding-name=VP8"',
        '!',
        'filesink',
        `location=${path.join(recordingDir, 'video.rtp')}`
      ]);

      // Extract ports from process output
      let audioPort = null;
      let videoPort = null;

      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout waiting for GStreamer ports'));
        }, 5000);

        audioProcess.stderr.on('data', (data) => {
          const port = this._extractPortFromOutput(data.toString());
          if (port && !audioPort) {
            audioPort = port;
            if (videoPort) {
              clearTimeout(timeout);
              this._setupRecordingProcess(clientId, audioProcess, videoProcess, audioPort, videoPort, timestamp);
              resolve({
                audioPipeline: { port: audioPort },
                videoPipeline: { port: videoPort },
                timestamp
              });
            }
          }
        });

        videoProcess.stderr.on('data', (data) => {
          const port = this._extractPortFromOutput(data.toString());
          if (port && !videoPort) {
            videoPort = port;
            if (audioPort) {
              clearTimeout(timeout);
              this._setupRecordingProcess(clientId, audioProcess, videoProcess, audioPort, videoPort, timestamp);
              resolve({
                audioPipeline: { port: audioPort },
                videoPipeline: { port: videoPort },
                timestamp
              });
            }
          }
        });

        audioProcess.on('error', reject);
        videoProcess.on('error', reject);
      });
    } catch (error) {
      console.error('Failed to start recording:', error);
      throw error;
    }
  }

  _setupRecordingProcess(clientId, audioProcess, videoProcess, audioPort, videoPort, timestamp) {
    this.recordingProcesses.set(clientId, {
      audio: {
        process: audioProcess,
        port: audioPort
      },
      video: {
        process: videoProcess,
        port: videoPort
      },
      timestamp
    });

    audioProcess.on('error', (err) => console.error('Audio recording error:', err));
    videoProcess.on('error', (err) => console.error('Video recording error:', err));
  }

  _extractPortFromOutput(output) {
    // GStreamer outputs something like "udpsrc0: actual-buffer-time = 0, actual-latency = 0, port = 12345"
    const match = output.match(/port\s*=\s*(\d+)/);
    return match ? parseInt(match[1], 10) : null;
  }

  stopRecording(clientId) {
    const recording = this.recordingProcesses.get(clientId);
    if (!recording) return;

    try {
      // Gracefully stop the GStreamer processes
      recording.audio.process.kill('SIGINT');
      recording.video.process.kill('SIGINT');
      
      this.recordingProcesses.delete(clientId);
      
      return recording.timestamp;
    } catch (error) {
      console.error('Error stopping recording:', error);
      throw error;
    }
  }

  startPlayback(clientId, timestamp) {
    const recordingDir = this.getRecordingPath(clientId, timestamp);
    
    try {
      // Start audio playback pipeline with raw RTP
      const audioProcess = spawn('gst-launch-1.0', [
        'filesrc',
        `location=${path.join(recordingDir, 'audio.rtp')}`,
        '!',
        'udpsink',
        'port=0',
        'host=127.0.0.1'
      ]);

      // Start video playback pipeline with raw RTP
      const videoProcess = spawn('gst-launch-1.0', [
        'filesrc',
        `location=${path.join(recordingDir, 'video.rtp')}`,
        '!',
        'udpsink',
        'port=0',
        'host=127.0.0.1'
      ]);

      // Extract ports from process output
      let audioPort = null;
      let videoPort = null;

      return new Promise((resolve, reject) => {
        const timeout = setTimeout(() => {
          reject(new Error('Timeout waiting for GStreamer ports'));
        }, 5000);

        audioProcess.stderr.on('data', (data) => {
          const port = this._extractPortFromOutput(data.toString());
          if (port && !audioPort) {
            audioPort = port;
            if (videoPort) {
              clearTimeout(timeout);
              this._setupPlaybackProcess(clientId, audioProcess, videoProcess, audioPort, videoPort);
              resolve({
                audioPipeline: { port: audioPort },
                videoPipeline: { port: videoPort }
              });
            }
          }
        });

        videoProcess.stderr.on('data', (data) => {
          const port = this._extractPortFromOutput(data.toString());
          if (port && !videoPort) {
            videoPort = port;
            if (audioPort) {
              clearTimeout(timeout);
              this._setupPlaybackProcess(clientId, audioProcess, videoProcess, audioPort, videoPort);
              resolve({
                audioPipeline: { port: audioPort },
                videoPipeline: { port: videoPort }
              });
            }
          }
        });

        audioProcess.on('error', reject);
        videoProcess.on('error', reject);
      });
    } catch (error) {
      console.error('Failed to start playback:', error);
      throw error;
    }
  }

  _setupPlaybackProcess(clientId, audioProcess, videoProcess, audioPort, videoPort) {
    this.playbackProcesses.set(clientId, {
      audio: {
        process: audioProcess,
        port: audioPort
      },
      video: {
        process: videoProcess,
        port: videoPort
      }
    });

    audioProcess.on('error', (err) => console.error('Audio playback error:', err));
    videoProcess.on('error', (err) => console.error('Video playback error:', err));
  }

  stopPlayback(clientId) {
    const playback = this.playbackProcesses.get(clientId);
    if (!playback) return;

    try {
      // Gracefully stop the GStreamer processes
      playback.audio.process.kill('SIGINT');
      playback.video.process.kill('SIGINT');
      
      this.playbackProcesses.delete(clientId);
    } catch (error) {
      console.error('Error stopping playback:', error);
      throw error;
    }
  }

  close() {
    // Clean up all running processes
    for (const [clientId] of this.recordingProcesses) {
      this.stopRecording(clientId);
    }
    for (const [clientId] of this.playbackProcesses) {
      this.stopPlayback(clientId);
    }
  }
}

module.exports = GstreamerManager; ---
FILENAME: src/MediasoupManager.js
CONTENTS:
const mediasoup = require('mediasoup');
const GstreamerManager = require('./GstreamerManager');

class MediasoupManager {
  constructor() {
    this.worker = null;
    this.router = null;
    this.gstreamerManager = new GstreamerManager();

    this.workerSettings = {
      rtcMinPort: 10000,
      rtcMaxPort: 10100,
      logLevel: 'warn',
      logTags: ['info', 'ice', 'dtls', 'rtp', 'srtp', 'rtcp']
    };

    this.mediaCodecs = [
      {
        kind: 'video',
        mimeType: 'video/VP8',
        clockRate: 90000,
        parameters: {
          'x-google-start-bitrate': 1000
        }
      },
      {
        kind: 'audio',
        mimeType: 'audio/opus',
        clockRate: 48000,
        channels: 2
      }
    ];
  }

  async init() {
    try {
      this.worker = await mediasoup.createWorker(this.workerSettings);
      console.log('MediaSoup Worker created');

      this.worker.on('died', () => {
        console.error('MediaSoup Worker died, exiting in 2 seconds... [pid:%d]', this.worker.pid);
        setTimeout(() => process.exit(1), 2000);
      });

      this.router = await this.worker.createRouter({ mediaCodecs: this.mediaCodecs });
      console.log('Router created');

      return true;
    } catch (error) {
      console.error('Failed to initialize MediasoupManager:', error);
      throw error;
    }
  }

  async createWebRtcTransport() {
    const transport = await this.router.createWebRtcTransport({
      listenIps: [
        {
          ip: '0.0.0.0',
          announcedIp: '127.0.0.1'
        }
      ],
      enableUdp: true,
      enableTcp: true,
      preferUdp: true,
    });

    transport.on('dtlsstatechange', dtlsState => {
      if (dtlsState === 'closed') {
        transport.close();
      }
    });

    transport.on('close', () => {
      console.log('Transport closed');
    });

    return {
      transport,
      params: {
        id: transport.id,
        iceParameters: transport.iceParameters,
        iceCandidates: transport.iceCandidates,
        dtlsParameters: transport.dtlsParameters
      }
    };
  }

  async connectWebRtcTransport(transport, dtlsParameters) {
    await transport.connect({ dtlsParameters });
  }

  async createProducer(transport, kind, rtpParameters) {
    return await transport.produce({ kind, rtpParameters });
  }

  async createConsumer(transport, producer, rtpCapabilities) {
    if (!this.router.canConsume({ producerId: producer.id, rtpCapabilities })) {
      throw new Error('Cannot consume this producer');
    }
    return await transport.consume({ producerId: producer.id, rtpCapabilities });
  }

  async startRecording(clientId, audioProducer, videoProducer) {
    try {
      const { audioPipeline, videoPipeline, timestamp } = this.gstreamerManager.startRecording(clientId);

      // Create plain RTP transports for GStreamer
      const audioRtpTransport = await this.router.createPlainTransport({
        listenIp: { ip: '127.0.0.1', announcedIp: null },
        rtcpMux: true,
        comedia: true
      });

      const videoRtpTransport = await this.router.createPlainTransport({
        listenIp: { ip: '127.0.0.1', announcedIp: null },
        rtcpMux: true,
        comedia: true
      });

      // Connect transports to GStreamer UDP ports
      await audioRtpTransport.connect({
        ip: '127.0.0.1',
        port: audioPipeline.port
      });

      await videoRtpTransport.connect({
        ip: '127.0.0.1',
        port: videoPipeline.port
      });

      // Create consumers for recording
      await audioRtpTransport.consume({
        producerId: audioProducer.id,
        rtpCapabilities: this.router.rtpCapabilities,
        paused: false
      });

      await videoRtpTransport.consume({
        producerId: videoProducer.id,
        rtpCapabilities: this.router.rtpCapabilities,
        paused: false
      });

      return timestamp;
    } catch (error) {
      console.error('Failed to start recording:', error);
      throw error;
    }
  }

  async stopRecording(clientId) {
    try {
      return await this.gstreamerManager.stopRecording(clientId);
    } catch (error) {
      console.error('Failed to stop recording:', error);
      throw error;
    }
  }

  async startPlayback(clientId, timestamp, transport) {
    try {
      const { audioPipeline, videoPipeline } = this.gstreamerManager.startPlayback(clientId, timestamp);

      // Create plain RTP transports for GStreamer playback
      const audioRtpTransport = await this.router.createPlainTransport({
        listenIp: { ip: '127.0.0.1', announcedIp: null },
        rtcpMux: true,
        comedia: true
      });

      const videoRtpTransport = await this.router.createPlainTransport({
        listenIp: { ip: '127.0.0.1', announcedIp: null },
        rtcpMux: true,
        comedia: true
      });

      // Connect transports to GStreamer UDP ports
      await audioRtpTransport.connect({
        ip: '127.0.0.1',
        port: audioPipeline.port
      });

      await videoRtpTransport.connect({
        ip: '127.0.0.1',
        port: videoPipeline.port
      });

      // Create producers from the GStreamer RTP streams
      const audioProducer = await audioRtpTransport.produce({
        kind: 'audio',
        rtpParameters: {
          codecs: [
            {
              mimeType: 'audio/opus',
              clockRate: 48000,
              channels: 2,
              parameters: {}
            }
          ],
          encodings: [{ ssrc: Math.floor(Math.random() * 9999999) + 1000 }]
        }
      });

      const videoProducer = await videoRtpTransport.produce({
        kind: 'video',
        rtpParameters: {
          codecs: [
            {
              mimeType: 'video/VP8',
              clockRate: 90000,
              parameters: {}
            }
          ],
          encodings: [{ ssrc: Math.floor(Math.random() * 9999999) + 1000 }]
        }
      });

      // Create consumers for the client
      const audioConsumer = await transport.consume({
        producerId: audioProducer.id,
        rtpCapabilities: this.router.rtpCapabilities,
        paused: false
      });

      const videoConsumer = await transport.consume({
        producerId: videoProducer.id,
        rtpCapabilities: this.router.rtpCapabilities,
        paused: false
      });

      return {
        audio: audioConsumer,
        video: videoConsumer
      };
    } catch (error) {
      console.error('Failed to start playback:', error);
      throw error;
    }
  }

  async stopPlayback(clientId) {
    try {
      await this.gstreamerManager.stopPlayback(clientId);
    } catch (error) {
      console.error('Failed to stop playback:', error);
      throw error;
    }
  }

  close() {
    this.gstreamerManager.close();
    if (this.worker) {
      this.worker.close();
    }
  }
}

module.exports = MediasoupManager; ---
FILENAME: src/WebSocketHandler.js
CONTENTS:
class WebSocketHandler {
  constructor(mediasoupManager) {
    this.mediasoupManager = mediasoupManager;
    this.clients = new Map(); // clientId -> {transport, producers, consumers}
    this.recordings = new Map(); // clientId -> {timestamp}
  }

  handleConnection(ws) {
    const clientId = Date.now().toString();
    console.log(`Client connected: ${clientId}`);

    this.clients.set(clientId, {
      ws,
      transport: null,
      producers: new Map(), // kind -> producer
      consumers: new Map(), // kind -> consumer
    });

    ws.on('message', async (message) => {
      try {
        const { type, data } = JSON.parse(message);
        await this.handleMessage(clientId, type, data);
      } catch (error) {
        console.error('Error handling message:', error);
        ws.send(JSON.stringify({ type: 'error', data: error.message }));
      }
    });

    ws.on('close', () => {
      console.log(`Client disconnected: ${clientId}`);
      this.handleDisconnect(clientId);
    });
  }

  async handleMessage(clientId, type, data) {
    const client = this.clients.get(clientId);
    if (!client) return;

    const { ws } = client;

    try {
      switch (type) {
        case 'getRouterRtpCapabilities': {
          ws.send(JSON.stringify({
            type: 'routerRtpCapabilities',
            data: this.mediasoupManager.router.rtpCapabilities
          }));
          break;
        }

        case 'createTransport': {
          const { transport, params } = await this.mediasoupManager.createWebRtcTransport();
          client.transport = transport;
          ws.send(JSON.stringify({
            type: 'transportCreated',
            data: params
          }));
          break;
        }

        case 'connectTransport': {
          const { dtlsParameters } = data;
          await this.mediasoupManager.connectWebRtcTransport(client.transport, dtlsParameters);
          ws.send(JSON.stringify({ type: 'transportConnected' }));
          break;
        }

        case 'produce': {
          const { kind, rtpParameters } = data;
          const producer = await this.mediasoupManager.createProducer(client.transport, kind, rtpParameters);
          client.producers.set(kind, producer);
          ws.send(JSON.stringify({
            type: 'produced',
            data: { id: producer.id, kind }
          }));
          break;
        }

        case 'startRecording': {
          const audioProducer = client.producers.get('audio');
          const videoProducer = client.producers.get('video');
          
          if (!audioProducer || !videoProducer) {
            throw new Error('Both audio and video producers must exist to start recording');
          }

          const timestamp = await this.mediasoupManager.startRecording(clientId, audioProducer, videoProducer);
          this.recordings.set(clientId, { timestamp });
          
          ws.send(JSON.stringify({
            type: 'recordingStarted',
            data: { timestamp }
          }));
          break;
        }

        case 'stopRecording': {
          const timestamp = await this.mediasoupManager.stopRecording(clientId);
          ws.send(JSON.stringify({
            type: 'recordingStopped',
            data: { timestamp }
          }));
          break;
        }

        case 'startPlayback': {
          const { timestamp } = data;
          const { audio: audioConsumer, video: videoConsumer } = 
            await this.mediasoupManager.startPlayback(clientId, timestamp, client.transport);

          client.consumers.set('audio', audioConsumer);
          client.consumers.set('video', videoConsumer);

          ws.send(JSON.stringify({
            type: 'playbackStarted',
            data: {
              audio: {
                id: audioConsumer.id,
                producerId: audioConsumer.producerId,
                kind: audioConsumer.kind,
                rtpParameters: audioConsumer.rtpParameters
              },
              video: {
                id: videoConsumer.id,
                producerId: videoConsumer.producerId,
                kind: videoConsumer.kind,
                rtpParameters: videoConsumer.rtpParameters
              }
            }
          }));
          break;
        }

        case 'stopPlayback': {
          await this.mediasoupManager.stopPlayback(clientId);
          client.consumers.clear();
          ws.send(JSON.stringify({ type: 'playbackStopped' }));
          break;
        }

        default:
          console.warn(`Unknown message type: ${type}`);
          break;
      }
    } catch (error) {
      console.error('Error handling message:', error);
      ws.send(JSON.stringify({
        type: 'error',
        data: error.message
      }));
    }
  }

  handleDisconnect(clientId) {
    const client = this.clients.get(clientId);
    if (!client) return;

    // Clean up MediaSoup resources
    for (const producer of client.producers.values()) {
      producer.close();
    }
    for (const consumer of client.consumers.values()) {
      consumer.close();
    }
    if (client.transport) {
      client.transport.close();
    }

    // Stop any ongoing recording or playback
    this.mediasoupManager.stopRecording(clientId).catch(console.error);
    this.mediasoupManager.stopPlayback(clientId).catch(console.error);

    this.clients.delete(clientId);
    this.recordings.delete(clientId);
  }
}

module.exports = WebSocketHandler;---
FILENAME: webpack.config.js
CONTENTS:
const path = require('path');
const webpack = require('webpack');
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  mode: 'development',
  entry: './public/client.js',
  output: {
    filename: 'bundle.js',
    path: path.resolve(__dirname, 'public/dist'),
  },
  optimization: {
    minimize: false // Disable minification for debugging
  },
  resolve: {
    fallback: {
      "buffer": require.resolve("buffer/"),
      "events": require.resolve("events/"),
      "process": require.resolve("process/browser"),
    },
    extensions: ['.js', '.json']
  },
  plugins: [
    new webpack.ProvidePlugin({
      Buffer: ['buffer', 'Buffer'],
      process: 'process/browser',
    }),
  ],
  module: {
    rules: [
      {
        test: /\.m?js$/,
        exclude: /node_modules\/(?!mediasoup-client)/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', {
                targets: {
                  browsers: ['last 2 versions', 'not dead']
                },
                modules: false // Keep ES modules
              }]
            ]
          }
        }
      }
    ]
  }
}; ---
